use std::error::Error;
use std::io::{self, BufRead};

fn parse_dimensions(line: &str) -> Result<(usize, usize), Box<dyn Error>> {
    let parts: Vec<&str> = line.split_whitespace().collect();
    let height = parts.get(1).ok_or("Height not found")?.parse::<usize>()?;
    let width = parts.get(2).ok_or("Width not found")?.parse::<usize>()?;
    Ok((height, width))
}

fn main() -> Result<(), Box<dyn Error>> {
    let stdin = io::stdin();
    let mut lines = stdin.lock().lines();

    let exec_line = lines.next().ok_or("No input line for exec")??;
    let _player = if exec_line.contains("p1") { 1 } else { 2 };

    let field_dims_line = lines
        .next()
        .ok_or("No input line for field dimensions")??
        .replace(":", ""); // Remove the colon
    let (field_width, field_height) = parse_dimensions(&field_dims_line)?;

    let mut anfield_input: Vec<Vec<char>> = Vec::new();
    println!("{}", field_height);
    lines.next();
    for _ in 0..field_height {
        let line = lines.next().unwrap()?;
        //println!("{}", line.chars().collect::<String>());
        //anfield_input.push(line.chars().collect());
    }
    println!("Here no work");

    let piece_dims_line = lines
        .next()
        .ok_or("No input line for piece dimensions")??
        .replace(":", ""); // Remove the colon
    let (piece_width, piece_height) = parse_dimensions(&piece_dims_line)?;

    let mut piece = Vec::new();
    for _ in 0..piece_height {
        let line = lines.next().ok_or("Missing piece line")??;
        piece.push(line);
    }

    // Read the piece dimensions but ignore as we're reading lines directly
    let _ = lines.next();
    if let Some((start_x, start_y)) = find_start_position(&anfield_input, '@') {
        // This example will try to place the piece right below the starting position
        let new_x = start_x + 1; // Go down one row
        let new_y = start_y; // Stay in the same column

        // Check if the new position allows you to place the piece within the Anfield bounds
        if new_x + piece.len() <= anfield_input.len()
            && new_y + piece[0].len() <= anfield_input[0].len()
        {
            println!("{} {}\\n", new_x, new_y);
        } else {
            // Can't place the piece at the calculated position. Return an invalid move.
            println!("0 0\\n");
        }
    } else {
        // Can't find a starting position. Return an invalid move.
        println!("0 0\\n");
    }
    println!("Finished!");
    Ok(())
}

fn find_start_position(anfield: &Vec<Vec<char>>, player_symbol: char) -> Option<(usize, usize)> {
    for (i, row) in anfield.iter().enumerate() {
        for (j, &cell) in row.iter().enumerate() {
            if cell == player_symbol {
                return Some((i, j));
            }
        }
    }
    None
}
